	Source Guide
	------------

Written by Eskil Steenberg (eskil@obsession.se)

This document guides threw the source files cat create "Loq Airou", "Quel solaar", ""co on", and the uv editor just known as "uv". Although these apps are separate they shard source code and are built on the same principles. Generally the code has very few comments, but it should still be fairly clear, whit the help of this guide. This guide will also include information on reading and writing in my coding style, please try to maintain the coding style if you modify the code.

	Modules and what they do
	-----------------------

The code is divided in to a number of modules they are "verse", "enough", "betray", "seduce" "Persuade" and "ST". All modules have header file named after the module (like enough.h and betray.h), all other files begins with the first letter of the name of the module followed by under score. So a file named e_head.c is a file used by Enough while s_main is a file used by Seduce. Outside a module only, the interface found in the main header files should be used. All application specific code is found in files that begin with the applications initials followed by under score. So files form "Loq Airou" are named la_... . In some cases multiple files in a module or app are in a "sub module" then they can be named to formed groups. for instance in the Loq Airous source files there are a number of files named far form a group with all the tools found in the popup menus, they are named la_tool_... In general I write fairly short .c files and the practice of having one .h files for ev
 ery .c file would not be very practical, because it would turn out to bee too many .h files contain only one or two externs. therefor many c files share h files. H files inside nodule are usually only used when many c files in one sub module needs to access the same data.


VERSE

Verse is not really a module in this packet it is in its own CVS, but it is needed by all applications, and written by the same person who wrote the other modules (me). In fact the module and the applications where created to show case verse. Verse it the real time network I/O that replaces all the file loading and saving in the apps. read more about verse at www.blender.org/modules/verse.

ST

st is a tiny module that include basic defines and some simple universally used functions. st does not require any other lib or module to compile.

ENOUGH

Enough is the storage lib that stores incoming data from verse. It downloads the basic structure of the content of the verse host it is connected to. Enough can handle multiple connections at the same time (although none of the apps or Persuade supports this). Enough does not download data, like Geometry and Bitmap layers until the user actually asks for it. Enough does not support any quick searching or advanced data storage such as subdivision or BSP. In enough you can store user pointers and function pointers that can be very use full if you want to store your own representations of the nodes. this is used extensively in "Co On" and in Persuade.

BETRAY

betray is the module that wraps all OS calls like access to input and opening windows. Betray can be compiled either against GLUT and SDL, both are highly portable and they should keep all applications portable. If you would like to port any of the apps to an other platform or give them native support on a platform where they already exist this is where you should add it. The betray module uses defines in the betray.h file to switch between the different routs. If you  would like to add some sort of system specific functionality, the betray api can be extended, but should be the same disregarding how betray is compiled. The user of betray should not have to read defines to know where or not some thing is available. The functionality may not work on all platforms but should at-least compile. 

Betray holds the main loop and calls a function pointer that the application gives it. The function call includes a pointer to  the very important structure "BInputState". This structure includes the position of the mouse pointer, the state of the mouse buttons, key events and other. It also holds a "mode". This is perhaps the most important thing to know about the source code that is kind of non obvious. because the function is not called once every frame but THREE times! Once is for drawing, once is for input and the third time is for computational updates. This means that betray can choose to update any of the events at it se fit. 

 For instance betray can run the compute command more gotten then the draw command and the draw command more often then the event command. This how ever means that all code has to check what mode it is currently running in. This may seam strange why not have there separate entry points, but there is actually a very good reason for this. imagine that you want to implement a button then you would create a function like this:

boolean my_nice_button(BInputState *input, float pos_x, float pos_y, char *name);

now inside this function i can switch to ether draw a button or, i can check if the user just clicked the button. The function will always return FALSE in draw mode, and that means that the app can use the function like this:

if(my_nice_button(input, 0.2, 0.4, "cut"))
	do_the_cutting();

now the do_the_cutting() function will only be called in event mode and never in draw mode. and as you can see it makes it fairly simple to to write interfaces whet you don't have to have two different functions to describe the interface that has to be synchronized.

The compute mode is usually branched away quickly and is only used for things like keeping verse alive, and doing computation that has nothing to do whit drawing or input. This mode is the only mode that will be called if the application is iconifyed.

SEDUCE

seduce is the basic interface modules used by all apps. Seduce  used to include buttons and other interface elements, but i have found it easier and more flexible to create ui tool kits ad hock for each application to make them fit better. So seduce mainly includes helper code that is used in all types of interfaces like checking if the mouse pointer is inside a rectangle, storing settings, typing in text and drawing text. In addition Seduce includes a editor for designing wire frame graphics used in all applications. Although this editor is some what limited it has made it easy to crate good looking icons and manipulators. seduce only requires st and betray to compile, and can be used to non verse related applications (in fact i have frequently used it for demos and rendering research projects)


PERSUADE

Persuade is a render library that is currently under construction, it uses OpenGL to draw verse data , It includes Subdivision geometry code, shading code using the openGL shading language. Persuade can be used to draw entire verse scenes but can also be used to to draw a specific geometry or get a GL handle to a texture provided by verse. Persuade requires enough and verse to compile. persuade has a built in "kernel" with a task manager that does all the computations. All computations are chopped up in small blocks that are computed one by one. This means that if some thing needs to be computed that is quite demanding it will be spit up and wont lock down the computer, meaning continuos smooth frame-rates disregarding of how much has to be done in the background.

Persuade is currently in development and is less then stabile. Therefor you can compile applications that use it whit out it simply by removing all the persuade files and replace persuade.h with a empty persuade.h file. (the presuade.h file contains the define "PERSUADE_H" if it isn't found the code that uses it will be removed by ifdefs)

	Building
	--------

To build one of the applications, compile and link all module files (including verse) with the files for the applications you want to build. Although the modules can be compiled as separate libs, I find easier to build them all at once. I keep them in one large project, It helps when debugging and lets me have access to the entire source base at any time.

All applications use the same set of external libs there are:

- Standard-lib 
- Sockets (wsock32.lib on windows)
- OpenGL 
- GLUT or SDL



.

Application specific code

Most of the application code is very straight forward. Each application has a main c file where you will find the man function. Each application then gives a pointer to Betray that will be the main loop. In most applications this function if first a main loop for the conect/login/splash screen. later when the application is connected the application gives betray the main loop function that will run the application. these main functions are found in the xx_input_handle.c files. These are possibly the most important file of the application here you will find the main file that traverses the users actions and makes use of all the functionality of the application, Note that this function is called three times per frame, Once to draw, once to activate functionality and once for pure computational updates.

Code style

My code style is best described by reading it, and if you are adding or modifying the code i would appreciate if you kept it consistent.

In general i try to keep all naming descriptive and prefer "vertex_count" rather then "vc", this does result in kind of wide code but i think it is important to keep it readable.

All functions, structures and type defs should start with the First letter of the module that they reside in, this makes it easy to always know from what module a function is taken. All functions, typedef members, and variables are written in lower case with underscores as dividers. all functions that are used as function pointers get the post fix "func", typedefed types are written in lower case with out any spaces. Macros, defines and enum members are all written in capital letters with under scores as spaces. Enum members should also have a sub category that defines in which enum they are defined. Structures and Enum types are written i lower case with lower case letters, but instead of under scores the first letter in each word is capital. 

Examples for the fictitious module "Leuq":

typedef unsigned int luint

typedef struct{
	float	silly;
	int 	very_silly;
	void	*noughty_bits;
}LMySillyStruct;

void l_my_hair_dryer(LHair *hair, float time);
void l_cut_short_func(LHair *hair, void *user); /* function used as pointer */

#define L_THERE_ARE_TOO_FEW_VERSE_APPS TRUE

typedef struct{
	L_MSE_ONE_WAY,
	L_MSE_OR_AN_OTHER
}LMySillyEnum;

I use the tab size of 4 in my editor.

-------------------------------------------------------
	Module API reference

	Enough
	------

Enough Is a simple storage lib that stores all in coming callbacks form verse. to send data changes back to verse, the normal verse.h API is used. Enough stores the data in a fairly simplistic way, it does not sort the data or prepare the data for any specific use, therefor if you use Enough you are likely to need to write a data conversion code on top of enough.

Ok lets start looking at the API:

1:managing connections:-----------------------

to initialize you first need to run : 
	void enough_init(void);

Enough can store more then one connection that you can switch between. you need to use Enoughs connect command rather then the verse.h connection command. so use:


	uint e_vc_connect(char *server_address, char *name, char *pass);

once you have sent the connection you can test to see if you got a connection.

extern boolean	e_vc_check_connected(void);
extern boolean	e_vc_check_connected_slot(uint	connection);
extern boolean	e_vc_check_accepted_slot(uint connection);

and disconnect using these functions:

extern void		e_vc_disconnect(uint	connection);
extern void		e_vc_disconnect_all(void);

To update the network and to switch the different connections you need to run:

extern void		e_vc_set_current_active_connection(uint connection);
extern void		e_vc_connection_update(uint connection, uint time);

 By default Enough will down load all node types but you can turn it on and off by calling: 

	void e_vc_set_auto_subscribe(VNodeType type, boolean set); 

2: Node handling-------------------------------- 

All nodes are handled using the type "ENode". the basic way of getting a node is by one of these functions:

	ENode *e_ns_get_node(uint connection, uint node_id);
	ENode *e_ns_get_node_next(uint id, uint connection, VNodeType type);
	ENode *e_ns_get_node_avatar(uint connection);
	ENode *e_ns_get_node_link(ENode *parent, uint node_id);

You can get the number of nodes of any type by calling:

	uint e_ns_get_node_count(uint connection, VNodeType type);

Once you have a node you can read out data from it by calling:

	uint e_ns_get_node_id(ENode *node);
	VNodeType e_ns_get_node_type(ENode *node);
	uint e_ns_get_node_owner(ENode *node);
	char *e_ns_get_node_name(ENode *node);
	uint e_ns_get_node_connection(ENode *node);

Remember that any ENode or underlying data or pointers become invalid every time you call network update. This is because the nodes may have been deleted or changed. So you have to store the node ids and the look up the node again.

Some data like geometry and bitmap layers will not be subscribed to until the user sends calls to get the data.  so if you want to use enough to write a saver you cant just connect, wait a while and then traverse the data. when you receive the data you need to traverse the layers and ask enough for pointers to the data. the first time they are requested they will return pointers pointing to blank data, but then they will start filling up as enough requests the data from the server. if you are writing a app that is connected to a host for a longer time this is very natural behavior.

3: Custom data-------------------------------- 

When you use enough you may still need to store your own custom data. Enough has various functionality's to this end.

	void e_ns_set_custom_data(ENode *node, uint slot, void *data);
	void *e_ns_get_custom_data(ENode *node, uint slot);

Can be used to store pointers for each node. there are 16 differently slots for each node. It is recommended that you use a define for the slot ids you use to store your data. by doing this it easier to switch slot if you want to merge your code whit other code bases that use enough as storage lib. How ever, this is not enough if the node gets deleted the slots will disappear and you will get a memory leak. therefor use this function: 


typedef enum{
	E_CDC_CREATE,
	E_CDC_STRUCT,
	E_CDC_DATA,
	E_CDC_DESTROY
}ECustomDataCommand;

	void e_ns_set_custom_func(uint slot, VNodeType type, void (*func)(ENode *node, ECustomDataCommand command));

this lets you assign call back that will be called when ever a node is created, destroyed or updated. Tis lets you write service functions that keep your custom data synced with verses data.

Now on top of this each node has 2 version numbers that can be used to see if a node has been updated or not.

	uint e_ns_get_node_version_struct(ENode *node);
	uint e_ns_get_node_version_data(ENode *node);

the data version is updated if there is any change to the node at all, and the structure version will only be updated if there is a structural change. For instance a new vertex, will result in a structural update , while moving a existing vertex will only be a data update. you can also poke at thees version numbers your self to force a update by calling:

	void e_ns_update_node_version_struct(ENode *node);
	void e_ns_update_node_version_data(ENode *node);

On top of all this functionality there is actually an other callback that you can give enough to call:

	void e_ns_set_node_create_func(void (* func)(uint connection, uint id, VNodeType type, void *user), void *user);

This callback is called when ever your connection receives a node create command form a node that you have asked to create. This is useful if you write a app that creates a node and then automatically want to add more data to it.

Similarly to the node graph, you can in the material graph store custom data and get update callbacks whit thees calls:

	uint e_nsm_get_fragment_version(ENode *node, VNMFragmentID id);

	void e_nsm_set_custom_data(ENode *node, VNMFragmentID frag, uint slot, void *data);
	void *e_nsm_get_custom_data(ENode *node, VNMFragmentID frag, uint slot);

	void e_nsm_set_custom_func(uint slot, void (*func)(ENode *node, VNMFragmentID frag, ECustomDataCommand command));

4: Node data-------------------------------- 

This is a very short documentation and most of the functionality is self explanatory if you know how verse works. But however there are some things to explain. Layers and other data have their own handles like:

	typedef void EObjLink;
	typedef void EGeoLayer;
	typedef void EBitLayer;
	typedef void ECodeBuffer;

They are obtained just like ENode handles using the same types of functions.

All of them have functions named "_next" this will give you the next available handles that has the same or higher id as the one given. This allows you to make loops that lists all nodes or layers. Here is an example of a loop that gives you all object nodes.

ENode *node;

for(node = e_ns_get_node_next(0, 0, V_NT_OBJECT); node != NULL; node = e_ns_get_node_next(e_ns_get_node_id(node) + 1, 0, V_NT_OBJECT)
{
	...
} 

Some data types doesn't have their own types and only ids are used. they have similar _next functions. here is an example of going threw all tag groups of a node:

for(id = e_ns_get_next_tag_group(node, 0); id != (uint16)-1; e_ns_get_next_tag_group(node, id + 1))

5: special node functions-------------------------------- 

Geometry node:

When modifying a geometry node one wants to add new vertices and polygon one needs empty ids. to do this use the functions:

	uint e_nsg_find_empty_vertex_slot(ENode *node, uint start);
	uint e_nsg_find_empty_polygon_slot(ENode *node, uint start);

use the "start" param if you need to more then one id. a typical loop to obtain ten id can look like this:
 
uint ids[10], i;

ids[0] = e_nsg_find_empty_vertex_slot(node, 0);

for(i = 1; i < 10; i++)
	ids[i] = e_nsg_find_empty_vertex_slot(node, ids[i - 1]);

Material node:

Bitmap node:

The bitmap node has the same type of functions as the other nodes. but it also has some extra functionality for read out colors form layers. All you need to do is to get a handle and then use that to read out a color at any uv. the functionality will handle , layer searching, data conversion, and pixel filtering and pixel lookup. here is an example:


EBMHandle *my_handle;
EBMPrecision my_pixel[3];

my_handle = e_nsb_get_image_handle(node_id, "col_r", "col_g", "col_b");
for(i = 0; i < 200; i++)
{
	e_nsb_evaluate_image_handle_tile(my_handle, my_pixel, u, v, w);
	...
}

e_nsb_destroy_image_handle(my_handle);

The image handle doesn't ever get in valid and will work even if the node gets deleted, or if layers are crated, destroyed, change name or type.

pburford@apple.com
vautherin.e@euro.apple.com

BETRAY

Betray has a very simple API that is very straight forward and should be easy use.

This code switches the compiler between using GLUT and SDL

/*#define BETRAY_SDL_SYSTEM_WRAPPER*/
#if !defined(BETRAY_SDL_SYSTEM_WRAPPER)
#define BETRAY_GLUT_SYSTEM_WRAPPER

Here are the three mode s that the action function can be called in:

typedef enum{
	BAM_DRAW,
	BAM_EVENT,
	BAM_MAIN
}BActionMode;

This stucture is the main structure given to the action function containing all the input data.

typedef struct{
	boolean			mouse_button[DEVICE_BUTTONS_COUNT];
	boolean			last_mouse_button[DEVICE_BUTTONS_COUNT];
	float			pointer_x;
	float			pointer_y;
	float			click_pointer_x;
	float			click_pointer_y;
	float			delta_pointer_x;
	float			delta_pointer_y;
	BButtonEvent	event[16];
	uint			event_count;
	double			time;
	BActionMode		mode;
}BInputState;

The mouse_button tells you whether or not a button is pressed. 

0 = Left mouse button
1 = Right mouse button
2 = Center mouse button

The last_mouse_button stores the value of the last frames mouse_button. this makes it possible to do tests like:

if(index->mouse_button[0] == TRUE && input->last_mouse_button[0] == FALSE)

To check for a button press.

pointer_x and pointer_y is the current position of the mouse. 
click_pointer_x and click_pointer_y is the position of the mouse the last time the left mouse button wasn't pressed. delta_pointer_x and delta_pointer_y is the delta movement of the pointer form the last frame. event and event count contains all key presses since the last frame.

	void betray_init(int argc, char **argv, uint window_size_x, uint window_size_y, boolean window_fullscreen, char *name);

Initializes betray and creates a window.

	void betray_action(BActionMode mode);

runs the current action func in a specific made (for testing mostly)

	void betray_set_action_func(void (*input_compute_func)(BInputState *data, void *user_pointer), void *user_pointer);

Setting the action function.

	void betray_set_mouse_warp(boolean warp);

Turn on or of the wrapping of the mouse for is that don't use the pointer (FPS type of controls) us the delta pointer field to read the mouse input. 

	void betray_execute(char *command);

used to execute a program outside the code.

	float betray_get_time();

Gives you the current time.

	void *betray_get_gl_proc_address();

gives you the address used by gl to get extension functions.

	boolean	betray_get_key(uint key);

Gives you a simple way to check if a key is pressed

	void betray_get_key_up_down(boolean *press, boolean *last_press, uint key);

Gives you the ability to read out a continuous state of a key, mouse button style.

	 BInputState *betray_get_input_state();

Gives you the input state i you have lost it, (used in Seduce to avid input params)

	void betray_reshape_view(uint x_size, uint y_size);

To set the screen size / mode to a specific mode call:

	boolean	betray_set_screen_mode(uint x_size, uint y_size, boolean fullscreen);

to read out the current screen size call the following function, it returns the aspect, and accepts NULL as any parameter.

	betray_get_screen_mode(uint *x_size, uint *y_size, boolean *fullscreen);

The betray lib has some special input functionality to handle text editing. to start the type in mode. simply call:

	void betray_start_type_in(char *text, uint size, void (*done_func)(void *user, boolean cancel), uint *curser, void *user_pointer);

"text" is a pointer to the buffer that is being edited. "size" is the size of that buffer. "curser" is pointer to a int where the editing cursor is in the buffer. "done_func" is a pointer to a function that will be called once the user presses enter or the following function:

	void betray_end_type_in_mode(boolean cancel);

You can check if you are in the type in mode.

	boolean betray_is_type_in();

To start the main loop you simply run:

	void betray_launch_main_loop(void);

Two functions to read the time independent of verse, although you should use verse timer API if you are timing anything like animation in the interface (too bad I haven't used in the apps so all the timing on the animation is all screwed up...) They also work before you have a communication.

	void betray_get_current_time(uint32 *seconds, uint32 *fractions);
double betray_get_delta_time();

betray_get_current_time works just like the timer function in verse. betray_get_delta_time returns the fraction of a section since the last draw frame.

SEDUCE

Seduce is the module that provides base functionality for ui interface.

To initialize Seduce call:

	void sui_init(void);

To draw a mouse pointer call:

	void sui_draw_pointer(float x, float y);

To create quadratic buttons or click areas these functions check if the mouse pointer is or was inside an area.

	boolean sui_box_click_test(float x_pos, float y_pos, float x_size, float y_size);
	boolean sui_box_down_click_test(float x_pos, float y_pos, float x_size, float y_size);

The perhaps largest functionality of SEDUCE is the built in vector line editor. They are arguably not very good and have been modified so many times a re write would not be bad, but since this is something only I have needed to use, and the functionality is manageable. To run the editor feed one of the following functions as action functions to Betray.

	void *sui_symbol_editor_func(BInputState *input, void *user_pointer);
	void *sui_font_editor_func(BInputState *input, void *user_pointer);

Once long ago there was an other module called NGL that wrapped GL, it has been removed but GL code can be quite talkative so to not make the code 5 times bigger i wrote a set of very simple functions to handle basic drawing using gl. If you want the details i suggest you look inside the code to get the full story. Any how to draw geometry i call:

	void sui_draw_gl(uint draw_type, float *array, uint length, uint dimensions, float red, float green, float blue);

	void sui_draw_elements_gl(uint draw_type, float *array, uint reference, uint length, uint dimensions, float red, float green, float blue);

To draw simple lines:

void sui_draw_2d_line_gl(float start_x, float start_y, float end_x, float end_y, float red, float green, float blue);
void sui_draw_3d_line_gl(float start_x, float start_y,  float start_z, float end_x, float end_y, float end_z, float red, float green, float blue);

void sui_set_blend_gl(uint source, uint destination);

To draw arrays with normals, colors or textures i call:

void sui_set_color_array_gl(float *array, uint length, uint channels);
void sui_set_normal_array_gl(float *array, uint length);
void sui_set_texture2D_array_gl(float *array, uint length, uint dimensions, uint texture);

The following functions (like much of the code above) is about saving lines of code. They simply set more then one value of an array. They may seem a little to simple but they kind of made the porting from NGL nicer....

void sui_draw_set_vec2(float *array, uint pos, float a, float b);
void sui_draw_set_vec3(float *array, uint pos, float a, float b, float c);
void sui_draw_set_vec4(float *array, uint pos, float a, float b, float c, float d);

void sui_draw_set_ivec2(uint *array, uint pos, uint a, uint b);
void sui_draw_set_ivec3(uint *array, uint pos, uint a, uint b, uint c);
void sui_draw_set_ivec4(uint *array, uint pos, uint a, uint b, uint c, uint d);

So one of the things that Seduce provides you with is the ability to  print out text. the letters are all drawn with lines using opengl. The font have ben drawn in  the editor above, and if you have problems whit it, you can just draw a new one! ;-)

First we have two defines for the standard size and spacing of text:

	#define SUI_T_SIZE 0.01 
	#define SUI_T_SPACE 0.3

Then to actually draw a single letter you use the function:

	void sui_draw_letter(uint8 letter, float red, float green, float blue);

To be able to do some simple kerning its nice to know how large the letter is:

	float sui_get_letter_size(char letter);

To draw a entire string of text with kerning and all call the following function. the "pos_x" and "pos_y" is where you would like to draw the text, "size" is the font size, "spacing" is the space between letters after kerning (normally SUI_T_SPACE), and "red", "green" and "blue" is the color,

	void sui_draw_text(float pos_x, float pos_y, float size, float spacing, char *text, float red, float green, float blue);

Sometimes it can be good to know how long a text will be once printed, to be able to do centering and other things. use the sam values as for sui_draw_text with the following to get the correct length.

	float sui_compute_text_length(float size, float spacing, char *text);

If you want a text button the next function does that for you. Remember that it does only draw a text it does not draw any button graphics. the param center lets you make the button left aligned (0), centered (0.5) or right aligned (1)

	boolean sw_text_button(BInputState *input, float pos_x, float pos_y, float center, float size, float spacing, char *text, float red, float green, float blue);

The Betray type in input API has been wrapped in Seduce to include click area and the printing of the text. All this wraps up in the function:

	boolean	sui_type_in(BInputState *input, float pos_x, float pos_y, float length, float size, char *text, uint buffer_size, void (*done_func)(void *user, char *text), void* user, float red, float green, float blue);

Note that the "length" is the length of the click area, and "size" is the size of the string.

Adding to this two similar functions have been added to handle the input of numerical values. They work very similarly, but please not the "id" pointer. This is a pointer that the function stores once activated to know what number is being activated. It can be any pointer that is unique and not given to the function in any other place. Often this pointer can be the same as the pointer to the value you are changing, but this isn't always practical. There are two different functions, one for doubles and one for integers they are:

	boolean sui_type_number_double(BInputState *input, float pos_x, float pos_y, float length, float size, double *number, void *id, float red, float green, float blue);

	boolean sui_type_number_uint(BInputState *input, float pos_x, float pos_y, float length, float size, uint32 *number, void *id, float red, float green, float blue);

Next is seduces settings API to initialize it, call the following function with the name of a settings file as argument.

	void sui_init_settings(char *settings);

To read out a setting or to set a setting you call the following functions whit a key word and a value or a default value that will be used if the setting doesn't not exist in the database. So you don't need to register the setting you just use it. Thees functions are not super fast so if you need the same setting many times, read it out to a temp value once rather then calling the functions in  an inner loop.

	double sui_get_setting_double(char *setting, double default_value);
	void sui_set_setting_double(char *setting, double value);
	uint sui_get_setting_int(char *setting, uint default_value);
	void sui_set_setting_int(char *setting, uint value);
	char *sui_get_setting_text(char *setting, char *default_text);
	void sui_set_setting_text(char *setting, char *text);
	boolean sui_test_setting_version(uint *version);

Finally to load or save your settings call the following with the name of the file as argument.

	void sui_save_settings(char *file_name);
	void sui_load_settings(char *file_name);

void sui_create_shadow_edge(float size, uint count, float *shadow, float *color, float *square);

Perhaps to most advanced function in Seduce is the popup function. It draws and executes popup menus. The buttons or areas in side the menus can be quite complicated and are described in the SUIPUElement structure. Once it is passed in to the function it will return the number of the element that got changed by the user.

	uint sui_draw_popup(BInputState *input, float pos_x, float pos_y, SUIPUElement *element, uint element_count, uint button);

